

/**
 * Deburr Scanner Configuration.
 */


// holds the previous scan result
var previousScan = [""];
// used to hold comparison of previous and current scan result
var notInLastRead = false;


/** 
 * This method is invoked on a successful code read.
 * @param decodeResults - Array of results and scan information produced by the scanner.
 * @param readerProperties - Array of Scanner Properties.
 * @param output - Array allowing customization of the output behavior of the Scanner.
 **/ 
function onResult(decodeResults, readerProperties, output) {
	// if the result was successfully decoded
	if (decodeResults[0].decoded) {
        // process the initial results ('|' -> ',' and remove all spaces)
		var processedResults = processResultString(decodeResults[0].content);
        // check the code output against the previously scanned code(s)
        notInLastRead = isStringNotInArray(previousScan, decodeResults[0].content);
        if (notInLastRead) {
            // shift out the previous scan and add the new scan into the list
            previousScan.shift();
            previousScan.push(decodeResults[0].content);
            // validate each field required for a Diecast Label to be captured
            var validPartNumber = validatePartNumber(processedResults[0]);
            var validDieNumber = validateDieNumber(processedResults[2]);
            var validQuantity = validateQuantity(processedResults[3]);
            var validDate = validateDateNoTime(processedResults[4]);
            var validShiftNumber = validateShiftNumber(processedResults[5]);
            var validJBKNumber = validateJBKNumber(processedResults[6])
            // if any of the validations failed, throw data validation error
            if (!validPartNumber || !validDieNumber || !validQuantity || !validDate || !validShiftNumber || !validJBKNumber) {
                dataValidationError(decodeResults, output, previousScan);
            } else {
                // generate a final output string, send it to the output module, and show a message on the screen
                var final = generateOutputString(readerProperties, processedResults);
                output.content = final;
                output.OLED = "<Message>";
            }
        // the code scanned matches the previously scanned code
        } else {
            duplicateScanError();
        }
    // results do not pass the validations
    } else {
        previousScan = dataValidationError(decodeResults, output, previousScan);
    }
}


/**
 * Helper Methods
 */


/**
 * Checks the passed Array for the passed String.
 * @param {string[]} array - The array to search in.
 * @param {String} string - The string to search `array` for.
 * @returns {boolean}
 */
function isStringNotInArray(array, string) {
	for (var i = 0; i < array.length; i++) {
		if (array[i] === string) {
			return false;
		}
	}
	return true;
}

/**
 * Processes a result string to remove spaces and replace bars with commas.
 * @param raw - The raw result string from the scanner output.
 * @returns {string[]}
 **/
function processResultString(raw) {
	// ensure the input is a string
	var input_string = String(raw);
    // split the string into an array by the bar symbol
    var input_list = input_string.split("|");
    // remove whitespace, comma, ampersand, and newline characters from each field
    for (var i = 0; i < length(input_list); i++) {
        _string = input_list[i];
        _string = _string.replace(/\s/g, "");
        _string = _string.replace(/\\000026/g, "");
        _string = _string.replace(/\n/g, "");
        _string = _string.replace(",", "")
        input_list[i] = _string;
    }
	// return the processed result array
	return input_list;
}

/**
 * Creates a final, formatted string that can be sent to the output module.
 * @param {Array} readerProperties - The `readerProperties` item created by the Scanner.
 * @param {string[]} processedResultList - The list of processed fields created by `processResultString()`
 * @returns {null}
 */
function generateOutputString(readerProperties, processedResultList) {
    // add the scanner information to the output
    // scanner_name
    var outputString = String(readerProperties.name);
    // scan time/date
    outputString += "," + String(readerProperties.trigger.creationDate).replace(/\s/g, "-");
    // scan results
    for (var i = 0; i < length(processedResultList); i++) {
        outputString += "," + String(processedResultList[i]);
    }
    // remove unnecessary GMT from the timestamp
    outputString = outputString.replace("-GMT-0400-", "");
}

/**
 * Throws a duplicate scan error to the Scanner. 
 * Sends a data validation failure command, sends a warning to the screen, and voids output.
 * @param {Array} output - The output module generated by the Scanner.
 * @returns {null}
 */
function duplicateScanError(output) {
    dmccCommand("OUTPUT.DATAVALID-FAIL");
    output.OLED = "Duplicate Label scanned";
    output.content = "";
}

/**
 * Throws a data validation error to the Scanner.
 * Sends a data validation failure command, sends a warning to the screen, and voids output.
 * Additionally, shifts `previousScan` to the `decodeResults` content. 
 * Returns the new `previousScan` array.
 * @param {*} decodeResults - The `decodeResults` produced by the Scanner.
 * @param {*} output - The `output` module created by the Scanner.
 * @param {*} previousScan - The `previousScan` array initialized in the beginning of the script.
 * @returns {string[]}
 */
function dataValidationError(decodeResults, output, previousScan) {
    dmccCommand("OUTPUT.DATAVALID-FAIL");
    output.OLED = "Please scan a Master Label to receive a shipment";
    output.content = "";
    // update the last scan
    previousScan.shift();
    previousScan.push(decodeResults[0].content);
    return previousScan
}


/**
 * Format Validator Methods.
 * 
 * Call each to validate the needed fields for each Label type.
 * 
 * Remove unused methods to avoid loading useless script onto the Scanner.
 */


/**
 * Validates a string as a Part Number using a regular expression test.
 * @param {string} string 
 * @returns {boolean}
 */
function validatePartNumber(string) {
	// set regex patterns for Part Number formats
	var pnPattern1 = /^\w\w-\w\w\w-\w\w\w\w\w-\w\w\w\w$/;
	var pnPattern2 = /^\w\w-\w\w\w-\w\w\w\w\w-\w\w\w\w-\w\w\w$/;
	var pnPattern3 = /^\w\w-\w\w\w-\w\w\w\w\w-\w\w\w\w-\w\w$/;
	var pnPattern4 = /^\w\w-\w\w\w\w-\w\w\w\w\w-\w\w\w\w-\w\w\w$/;
	// check for each of the defined part number formats
	if (pnPattern1.test(string)) {
		return true;	
	}
	if (pnPattern2.test(string)) {
		return true;	
	}
	if (pnPattern3.test(string)) {
		return true;	
	}
	if (pnPattern4.test(string)) {
		return true;	
	}
	// none of the checks were successful
	return false;
}

/**
 * Validates a string as a Date (without a timestamp) using a regular expression test.
 * @param {string} string 
 * @returns {boolean}
 */
function validateDateNoTime(string) {
    // set a regex pattern for Date format
    var datePattern = /^\d\d\/\d\d\/\d\d\d\d$/;
	if (datePattern.test(string)) {
		return true;	
	} else {
        return false;
    }
}

/**
 * Validates a string as a Shift Number.
 * @param {string} string 
 * @returns {boolean}
 */
function validateShiftNumber(string) {
    // check that the string is 1, 2, or 3
    if (["1", "2", "3"].includes(string)) {
        return true;
    } else {
        return false;
    }
}

/**
 * Validates a string as a JBK Number. Enforces three-length format; returns the string in this format.
 * @param {string} string 
 * @returns {boolean | Array}
 */
function validateJBKNumber(string) {
    // set a regex pattern for JBK numbers
    var jbkPattern = /^[\d]?[\d]?[\d]$/;
    if (datePattern.test(string)) {
        // ensure JBK is three digits by adding 0s
        while (length(string) < 3) {
            string = "0" + string;
        }
		return [true, string];	
	} else {
        return false;
    }
}

/**
 * Validates a string as a Quantity.
 * @param {string} string 
 * @returns {boolean}
 */
function validateQuantity(string) {
    // set a regex pattern for Quantities
    var quantityPattern = /^\d+$/;
    if (quantityPattern.test(string)) {
		return true;	
	} else {
        return false;
    }
}

/**
 * Validates a string as a Die Number.
 * @param {string} string 
 * @returns {boolean}
 */
function validateDieNumber(string) {
    // set a regex pattern for Die Numbers
    var diePattern = /^\d?\d?\d$/;
    if (diePattern.test(string)) {
		return true;	
	} else {
        return false;
    }
}